- rule_id: "CR-001"
  title: "クリーンアーキテクチャのディレクトリ構造を遵守する"
  description: "プロジェクトの保守性とテスト容易性を維持するため、ソースコードは必ず`domain`, `usecase`, `adapter`, `infrastructure`の各レイヤーに適切に配置する。依存関係のルール（内側から外側へは依存しない）を厳守すること。"
  category: "設計原則"
  example_bad: |
    # main.gs (infrastructure)
    # ドメインロジックやAPI通信のロジックが混在している
    function postTweet() {
      const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Queue");
      const data = sheet.getRange("A2").getValue();
      // 文字数チェックなどのドメインロジック
      if (data.length > 140) {
        throw new Error("文字数オーバー");
      }
      // API通信
      UrlFetchApp.fetch("https://api.twitter.com/...", ...);
    }
  example_good: |
    # hatolink/infrastructure/triggers.js (エントリーポイント)
    import { PostScheduledTweetsUseCase } from '../usecase/PostScheduledTweetsUseCase';
    
    function runPostScheduledTweets() {
      const useCase = new PostScheduledTweetsUseCase(/* 依存性の注入 */);
      useCase.execute();
    }
- rule_id: "CR-002"
  title: "テストディレクトリの運用ルールを明確化する"
  description: "テストコードは/app/tests配下に集約し、アプリケーション本体と分離して管理する。テストの配置場所や命名規則を統一し、可搬性・保守性を高める。"
  category: "テスト運用"
  example_bad: |
    # hatolink/infrastructure/tests/sample.test.js
    // 本体ディレクトリ内にテストが混在している
  example_good: |
    # /app/tests/sample.test.js
    // すべてのテストは/app/tests配下に集約
- rule_id: "CR-003"
  title: "ドキュメント・計画・レビューの一元管理"
  description: "test_requirements.md, coding-rules.yml, 各種計画・レビューリクエスト等のドキュメントはdocs配下に整理し、用途ごとにサブディレクトリ（plans, reviews等）を設けて管理する。"
  category: "ドキュメント運用"
  example_bad: |
    # /app/test_requirements.md
    # /app/coding-rules.yml
    # /app/TASK-001-plan.yml
  example_good: |
    # /app/docs/test_requirements.md
    # /app/docs/coding-rules.yml
    # /app/docs/plans/TASK-001-plan.yml
    # /app/docs/reviews/review-request-TASK-001.md
- rule_id: "CR-004"
  title: "ユースケースはインターフェースのみに依存し、具象クラスに依存しない"
  description: "ユースケース層の実装では、リポジトリやAPIアダプタ等のインターフェースにのみ依存し、具象クラスや外部実装には直接依存しないこと。これによりテスト容易性と保守性を高める。"
  category: "設計原則"
  example_bad: |
    // 具象クラスに依存したユースケース
    const repo = new SpreadsheetTweetRepository();
    const api = new TwitterApiImpl();
    const useCase = new PostScheduledTweetsUseCase(repo, api);
  example_good: |
    // インターフェースに依存したユースケース
    const useCase = new PostScheduledTweetsUseCase(tweetRepository, twitterApi); // どちらもインターフェース型
- rule_id: "CR-005"
  title: "外部API連携における失敗許容設計"
  description: "UrlFetchAppなどで外部APIと通信する際は、muteHttpExceptionsオプションをtrueに設定し、HTTPエラーステータスコード（4xx, 5xx）を例外としてではなく戻り値としてハンドルすること。これにより、APIの一時的な不調やリクエストの不備が、システム全体の実行停止に直結するのを防ぎ、より柔軟なエラーハンドリングを可能にする。"
  category: "外部連携"
  example_bad: |
    // muteHttpExceptionsが未設定のため、APIが401等を返すとスクリプト全体が例外で停止する
    try {
      const response = UrlFetchApp.fetch("https://api.example.com/data");
      // ... 成功時の処理
    } catch (e) {
      // ネットワークエラーは捕捉できるが、HTTPエラーは捕捉できない
      Logger.log(e);
    }
  example_good: |
    // muteHttpExceptions: true を設定
    const options = {
      'method': 'get',
      'muteHttpExceptions': true
    };
    const response = UrlFetchApp.fetch("https://api.example.com/data", options);
    const responseCode = response.getResponseCode();

    if (responseCode === 200) {
      // ... 成功時の処理
    } else {
      // 失敗時の処理（ログ記録など）
      Logger.log(`API error: ${responseCode} - ${response.getContentText()}`);
    }
- rule_id: "CR-006"
  title: "ドメインの不変条件はドメインレイヤーでカプセル化する"
  description: "エンティティや値オブジェクトが持つべきビジネスルール（不変条件）は、必ずドメインレイヤー内で検証・保証されなければならない。Use Case層やAdapter層でドメインのルールをチェックするようなコードは、責務の漏洩であり、モデルの価値を破壊するため禁止する。"
  category: "設計原則"
  example_bad: |
    # UseCase層で文字数チェックを行っている悪い例
    class PostTweetUseCase {
      execute(tweetData) {
        if (tweetData.body.length > 140) { // ドメインのルールが漏洩している
          throw new Error("文字数超過");
        }
        // ...
      }
    }
  example_good: |
    # ドメイン層(値オブジェクト)で文字数チェックを完結させている良い例
    class TweetBody {
      constructor(body) {
        if (body.length > 140) {
          throw new Error("文字数超過");
        }
        this.value = body;
      }
    }
- rule_id: "CR-007"
  title: "GASのグローバルオブジェクトはAdapter層でラップし、テスト容易性を確保する"
  description: "SpreadsheetAppやUrlFetchAppのようなGASのグローバルオブジェクトは、直接呼び出すとテスト時のモック化が困難になる。これらのオブジェクトへのアクセスは必ずAdapter層にカプセル化し、他のレイヤー（特にUseCase層）が直接依存しないように設計すること。これにより、各コンポーネントの単体テストの独立性と信頼性を高める。"
  category: "テスト設計"
  example_bad: |
    # UseCase層が直接SpreadsheetAppに依存している
    class SomeUseCase {
      execute() {
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Data");
        const data = sheet.getRange("A1").getValue();
        # ...
      }
    }
  example_good: |
    # Adapter層でラップし、UseCaseはインターフェースに依存する
    # IDataRepository.js (in usecase layer)
    class IDataRepository { find() {} }

    # SpreadsheetAdapter.js (in adapter layer)
    class SpreadsheetAdapter extends IDataRepository {
      find() {
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Data");
        return sheet.getRange("A1").getValue();
      }
    }
